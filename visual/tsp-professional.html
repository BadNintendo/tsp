<canvas id="canvas" width="500" height="500"></canvas>
<p id="info"></p> <!-- For displaying hover info -->
<script>
const solveSatisfiabilityAndTSP = async (cities) => {
    const memoizedDistances = {};

    /** Calculates Euclidean distance between two cities with memoization.
     * @param {Object} city1 - First city with properties {name, x, y}.
     * @param {Object} city2 - Second city with properties {name, x, y}.
     * @returns {Promise<number>} - The calculated distance.
     */
    const calculateDistance = async (city1, city2) => {
        const key = `${city1.name}-${city2.name}`;
        if (!memoizedDistances[key]) {
            memoizedDistances[key] = Math.hypot(city1.x - city2.x, city1.y - city2.y);
        }
        return memoizedDistances[key];
    };

    /** Calculates total path distance.
     * @param {Array} path - Array of cities in the path.
     * @returns {Promise<number>} - The total calculated distance.
     */
    const totalDistance = async (path) => {
        return path.reduce(async (accPromise, city, i, arr) => {
            const acc = await accPromise;
            const nextCity = arr[(i + 1) % arr.length];
            const dist = await calculateDistance(city, nextCity);
            return acc + dist;
        }, Promise.resolve(0));
    };

    /** Implements the Nearest-Neighbor approach to approximate TSP.
     * @param {Array} cities - Array of cities.
     * @returns {Promise<Object>} - Object containing the path and total distance.
     */
    const tspNearestNeighbor = async (cities) => {
        const unvisited = new Set(cities.map(city => city.name));
        const path = [cities[0]];
        let currentCity = cities[0];

        while (unvisited.size > 0) {
            unvisited.delete(currentCity.name);
            const nextCity = await cities.reduce(async (closestPromise, city) => {
                const closest = await closestPromise;
                if (unvisited.has(city.name)) {
                    const dist = await calculateDistance(currentCity, city);
                    if (!closest || dist < closest.distance) return { city, distance: dist };
                }
                return closest;
            }, Promise.resolve(null));

            if (!nextCity) break;
            path.push(nextCity.city);
            currentCity = nextCity.city;
        }
        
        const distance = await totalDistance(path);
        return { path, distance };
    };

    /** Optimizes path with 2-opt swap technique.
     * @param {Array} path - Initial path of cities from TSP solution.
     * @returns {Promise<Array>} - The optimized path.
     */
    const twoOpt = async (path) => {
        let improved = true;
        
        // Continuously attempt to improve the path until no further improvements
        while (improved) {
            improved = false;
            
            // Recursive two-opt swap logic to try all pairs of cities and swap if distance is reduced
            await path.reduce(async (previousPromise, _, i) => {
                await previousPromise;
                return path.slice(i + 2).reduce(async (innerPromise, __, j) => {
                    await innerPromise;
                    
                    // Create potential new path by reversing segment between i and j
                    const newPath = [
                        ...path.slice(0, i),
                        ...path.slice(i, i + j + 2).reverse(),
                        ...path.slice(i + j + 2)
                    ];
                    
                    const currentDistance = await totalDistance(path);
                    const newDistance = await totalDistance(newPath);
                    
                    // Replace path if new path has a shorter distance
                    if (newDistance < currentDistance) {
                        path = newPath;
                        improved = true;
                    }
                }, Promise.resolve());
            }, Promise.resolve());
        }
        
        return path;
    };

    // Pre-calculate distances for all city pairs to improve memoization efficiency.
    const preCalcStart = performance.now();
    await Promise.all(cities.flatMap(city1 =>
        cities.map(city2 => calculateDistance(city1, city2))
    ));
    const preCalcEnd = performance.now();
    console.log(`Pre-calculation time: ${preCalcEnd - preCalcStart}ms`);

    // Run initial TSP solution using the Nearest-Neighbor approach.
    const tspStart = performance.now();
    const tspResult = await tspNearestNeighbor(cities);
    const tspEnd = performance.now();
    console.log(`TSP Nearest Neighbor time: ${tspEnd - tspStart}ms`);

    // Optimize the TSP result with the 2-opt algorithm.
    const twoOptStart = performance.now();
    const optimizedPath = await twoOpt(tspResult.path);
    const twoOptEnd = performance.now();
    console.log(`2-opt Optimization time: ${twoOptEnd - twoOptStart}ms`);

    const optimizedDistance = await totalDistance(optimizedPath);

    const totalEnd = performance.now();
    console.log(`Total execution time: ${totalEnd - preCalcStart}ms`);

    // Return the optimized path and distance.
    return {
        tspPath: optimizedPath.map(city => city.name),
        tspDistance: optimizedDistance,
    };
};

const cities = [
  {
      "name": "City1",
      "x": 8.69137830994713,
      "y": 46.44025316199729
  },
  {
      "name": "City2",
      "x": 55.30259522197798,
      "y": 90.43313399637462
  },
  {
      "name": "City3",
      "x": 16.578891890873358,
      "y": 21.941089157246285
  },
  {
      "name": "City4",
      "x": 21.889295164734857,
      "y": 90.76024184372531
  },
  {
      "name": "City5",
      "x": 88.19071285347344,
      "y": 48.020594727638596
  },
  {
      "name": "City6",
      "x": 58.43743154322216,
      "y": 29.432209030993416
  },
  {
      "name": "City7",
      "x": 68.0602007070311,
      "y": 56.711846045347045
  },
  {
      "name": "City8",
      "x": 36.701385811059154,
      "y": 71.19188879624163
  },
  {
      "name": "City9",
      "x": 0.01873875607718567,
      "y": 11.009963340473883
  },
  {
      "name": "City10",
      "x": 52.849121177865484,
      "y": 6.996053948555581
  },
  {
      "name": "City11",
      "x": 68.87471857229117,
      "y": 32.79663260556893
  },
  {
      "name": "City12",
      "x": 1.8677580833082352,
      "y": 7.147315398048604
  },
  {
      "name": "City13",
      "x": 1.5993246161458252,
      "y": 88.35835402837688
  },
  {
      "name": "City14",
      "x": 80.95162106158304,
      "y": 29.56421853192648
  },
  {
      "name": "City15",
      "x": 57.1730028284754,
      "y": 50.84701012104242
  },
  {
      "name": "City16",
      "x": 75.62937521934225,
      "y": 40.15212233595569
  },
  {
      "name": "City17",
      "x": 71.07542840053786,
      "y": 48.00426558897224
  },
  {
      "name": "City18",
      "x": 51.48724675403036,
      "y": 15.61233843048253
  },
  {
      "name": "City19",
      "x": 44.1889027670048,
      "y": 4.163829807832364
  },
  {
      "name": "City20",
      "x": 13.301293259873482,
      "y": 77.2725096650387
  },
  {
      "name": "City21",
      "x": 39.15614503807894,
      "y": 8.26083071471071
  },
  {
      "name": "City22",
      "x": 53.536069024598774,
      "y": 25.890730248514913
  },
  {
      "name": "City23",
      "x": 91.16993109630565,
      "y": 64.88857330981139
  },
  {
      "name": "City24",
      "x": 14.00802641367922,
      "y": 61.91699631754239
  },
  {
      "name": "City25",
      "x": 9.437485293356328,
      "y": 89.16591866484033
  },
  {
      "name": "City26",
      "x": 76.17762384044224,
      "y": 3.079928487278072
  },
  {
      "name": "City27",
      "x": 11.309276152034876,
      "y": 88.7217041195026
  },
  {
      "name": "City28",
      "x": 33.75588253715929,
      "y": 45.84382474832407
  },
  {
      "name": "City29",
      "x": 86.78820119746906,
      "y": 35.96192558213864
  },
  {
      "name": "City30",
      "x": 91.50162227511187,
      "y": 23.868459984934276
  },
  {
      "name": "City31",
      "x": 1.0500530517091544,
      "y": 45.286742424156
  },
  {
      "name": "City32",
      "x": 26.27891535397131,
      "y": 12.457873639735961
  },
  {
      "name": "City33",
      "x": 48.59970652086212,
      "y": 55.97853729870883
  },
  {
      "name": "City34",
      "x": 4.669618271949982,
      "y": 2.0054758337797463
  },
  {
      "name": "City35",
      "x": 50.559384362820836,
      "y": 28.540072467252386
  },
  {
      "name": "City36",
      "x": 34.38351827124786,
      "y": 51.75418357394437
  },
  {
      "name": "City37",
      "x": 52.36468736363564,
      "y": 90.72482484358298
  },
  {
      "name": "City38",
      "x": 53.12962412424702,
      "y": 10.471468910106484
  },
  {
      "name": "City39",
      "x": 39.53355513393695,
      "y": 15.237526268184553
  },
  {
      "name": "City40",
      "x": 1.5078813730161622,
      "y": 73.11111241364144
  },
  {
      "name": "City41",
      "x": 19.03814712034586,
      "y": 75.71393597271016
  },
  {
      "name": "City42",
      "x": 88.52309081434208,
      "y": 85.48824757237898
  },
  {
      "name": "City43",
      "x": 16.473186873952184,
      "y": 81.7288772108241
  },
  {
      "name": "City44",
      "x": 20.317397223198164,
      "y": 45.4903074216577
  },
  {
      "name": "City45",
      "x": 15.45326001812577,
      "y": 26.095975246720272
  },
  {
      "name": "City46",
      "x": 92.16901728411901,
      "y": 53.744222254344606
  },
  {
      "name": "City47",
      "x": 65.49405780609573,
      "y": 23.62228717082846
  },
  {
      "name": "City48",
      "x": 64.43265970482214,
      "y": 31.98511346309063
  },
  {
      "name": "City49",
      "x": 57.07000973821559,
      "y": 39.18306416449566
  },
  {
      "name": "City50",
      "x": 80.44488707787619,
      "y": 59.48553318002872
  }
];

solveSatisfiabilityAndTSP(cities).then(result => {
    console.log("TSP Path:", result.tspPath);
    console.log("TSP Distance:", result.tspDistance);
});

// Get the canvas element and its 2D rendering context
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

/**
 * Calculates the maximum X and Y values in the dataset.
 * Used to scale the coordinates of each city to fit within the canvas dimensions.
 */
const maxX = Math.max(...cities.map(item => item.x));
const maxY = Math.max(...cities.map(item => item.y));

/**
 * Scale factors for the X and Y axes to fit the dataset onto the canvas.
 * These scale factors adjust the coordinates so that all cities are visible on the canvas.
 */
const scaleX = canvas.width / maxX;
const scaleY = canvas.height / maxY;

// Set the background color of the canvas to black
canvas.style.backgroundColor = 'black';

// Initialize variables to track the mouse position on the canvas
let mouseX = 0;
let mouseY = 0;

// The radius of each dot representing a city, used for hover detection
const dotRadius = 5;

/**
 * Generates a random RGB color for each city dot.
 * @returns {string} - A random RGB color string in the format 'rgb(r, g, b)'.
 */
const getRandomColor = () => {
  const r = Math.floor(Math.random() * 256); // Red component
  const g = Math.floor(Math.random() * 256); // Green component
  const b = Math.floor(Math.random() * 256); // Blue component
  return `rgb(${r}, ${g}, ${b})`; // Return the color string
};

// Iterate over the dataset of cities to draw each city as a dot
cities.forEach(item => {
  // Scale the X and Y coordinates to fit within the canvas dimensions
  const scaledX = item.x * scaleX;
  const scaledY = item.y * scaleY;

  // Get a random color for the city dot
  const color = getRandomColor();

  // Draw the dot on the canvas at the scaled coordinates
  ctx.beginPath();
  ctx.arc(scaledX, scaledY, dotRadius, 0, Math.PI * 2); // Create a circle with the specified radius
  ctx.fillStyle = color; // Set the fill color to the random color
  ctx.fill(); // Fill the circle with the color
  ctx.closePath(); // Close the path after filling

  // Store the color and scaled coordinates for future reference
  item.color = color;
  item.scaledX = scaledX;
  item.scaledY = scaledY;
});

/**
 * Function to check if the mouse is hovering over any of the city dots.
 * Updates the displayed city information if a dot is hovered.
 */
const checkHover = () => {
  let hoveredCity = null; // To store the city that is being hovered over
  
  // Loop through each city and check if the mouse is within the radius of the dot
  cities.forEach(item => {
    // Calculate the distance between the mouse position and the city dot
    const dx = mouseX - item.scaledX;
    const dy = mouseY - item.scaledY;
    const distance = Math.sqrt(dx * dx + dy * dy); // Euclidean distance formula

    // If the mouse is close enough to the dot, consider it hovered
    if (distance < dotRadius) {
      hoveredCity = item;
    }
  });

  // If a city is being hovered over, display its name and coordinates
  if (hoveredCity) {
    document.getElementById('info').innerText = `Name: ${hoveredCity.name}, X: ${hoveredCity.x}, Y: ${hoveredCity.y}`;
  } else {
    // Clear the info display if no city is hovered
    document.getElementById('info').innerText = '';
  }
};

// Event listener to track mouse movement over the canvas
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect(); // Get the canvas's position relative to the viewport
  mouseX = e.clientX - rect.left; // Calculate the mouse's X position relative to the canvas
  mouseY = e.clientY - rect.top;  // Calculate the mouse's Y position relative to the canvas
  checkHover(); // Check if the mouse is hovering over any city dots
});

</script>
